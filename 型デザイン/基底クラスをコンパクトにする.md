## 基底クラスをコンパクトにする

### 基底クラスが肥大化することの問題点

1. **単一責任の原則に違反する**:
    - オブジェクト指向設計の重要な原則の一つである単一責任の原則（Single Responsibility Principle, SRP）に反します。基底クラスが多くの機能を持つようになると、そのクラスの変更が複数の理由で必要になり、管理が難しくなります。

2. **再利用性の低下**:
    - 基底クラスが多くの機能を持つ場合、そのクラスを継承するサブクラスは必然的に不要な機能も継承することになります。これにより、サブクラスの再利用性が低下します。

3. **テストの複雑化**:
    - クラスが多くの責任を持つと、そのテストが複雑になり、テストケースの数も増加します。結果として、テストの維持管理が難しくなります。

4. **結合度の増加**:
    - 基底クラスに多くの機能が追加されると、そのクラスと依存するクラスとの結合度が高くなります。これは、変更に対する影響範囲が広がることを意味し、メンテナンスコストが増加します。

### 基底クラスの肥大化を回避する方法

1. **単一責任の原則を適用する**:
    - クラスごとに一つの責任を持たせるように設計します。これにより、クラスの肥大化を防ぎ、クラスの変更理由を明確にします。

2. **インターフェースの使用**:
    - 共通の機能を持つ複数のクラスに対してインターフェースを定義し、必要な機能だけを実装するようにします。これにより、クラス間の結合度を低く保ち、再利用性を向上させます。

3. **デコレーター（装飾）パターンの適用**:
    - 基本機能を持つ基底クラスと、その機能を拡張するデコレータクラスを用意します。これにより、クラスの責任を分割し、基底クラスの肥大化を防ぎます。

4. **コンポジションの使用**:
    - 継承の代わりにコンポジション（オブジェクトの組み合わせ）を使用します。必要な機能を持つクラスを組み合わせて新しいクラスを構成し、クラスの肥大化を防ぎます。

### 具体例

以下に、基底クラスが肥大化することを避けるための具体的なコード例を示します。

#### 悪い例：基底クラスの肥大化

```csharp
public class Animal
{
    public void Eat() { /*...*/ }
    public void Sleep() { /*...*/ }
    public void Walk() { /*...*/ }
    public void Fly() { /*...*/ }
    public void Swim() { /*...*/ }
}
```

#### 良い例：インターフェースとコンポジションの使用

```csharp
public interface IWalker
{
    void Walk();
}

public interface IFlyer
{
    void Fly();
}

public interface ISwimmer
{
    void Swim();
}

public class Animal
{
    public void Eat() { /*...*/ }
    public void Sleep() { /*...*/ }
}

public class Bird : Animal, IWalker, IFlyer
{
    public void Walk() { /*...*/ }
    public void Fly() { /*...*/ }
}

public class Fish : Animal, ISwimmer
{
    public void Swim() { /*...*/ }
}

```

### まとめ

基底クラスの肥大化は、単一責任の原則に違反し、再利用性やテストの複雑化、結合度の増加などの問題を引き起こします。これを回避するためには、単一責任の原則を適用し、インターフェースの使用、デコレータパターンの適用、コンポジションの使用などの設計手法を採用することが重要です。
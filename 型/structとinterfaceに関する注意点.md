## structとinterfaceに関する注意点

値型である構造体（struct）にインターフェースを実装することはデメリットがある可能性があります。

### ボックス化によるパフォーマンス低下

構造体がインターフェースを実装すると、**その構造体がインターフェース型にキャストされたときに**ボックス化が発生します。ボックス化とは、値型（struct）が参照型（objectやインターフェース型など）に変換されるプロセスです。ボックス化のプロセスは以下のようなコストを伴います：

1. **メモリアロケーション**: ヒープにメモリが確保されるため、ガベージコレクションの負荷が増えます。
2. **パフォーマンスオーバーヘッド**: ボックス化とボックス化解除（アンボックス化）の操作には構造体であるメリットを完全に打ち消すほどの処理コストがあります。

### 可変性の問題

構造体は値型であり、通常は不変（immutable）として設計することが推奨されます。しかし、インターフェースを実装すると、インターフェースのメソッドを呼び出す際に構造体のコピーが生成されるため、意図せずして変更が元のインスタンスに反映されないという問題が発生します。

```csharp
interface IExample
{
    void DoSomething();
}

struct MyStruct : IExample
{
    public int Value;

    public void DoSomething() => Value++;
}

IExample example = new MyStruct();
example.DoSomething();
// この時点で example はボックス化されており、元の構造体には変更が反映されない
```
### API設計上の一貫性

構造体がインターフェースを実装すると、API利用者はその構造体が値型であるか参照型であるかを気にせず使用する可能性があります。しかし、これは直感的でない挙動を引き起こし、コードの可読性や保守性を低下させることがあります。

### まとめ

1. **ボックス化によるパフォーマンス低下**: 値型から参照型への変換が頻繁に発生し、メモリアロケーションとパフォーマンスのオーバーヘッドが増加する。
1. **可変性の問題**: インターフェースメソッドの呼び出し時に構造体がコピーされ、元のインスタンスが予期せず変更されないことがある。
1. **API設計上の一貫性**: 構造体とインターフェースの組み合わせが直感的でない挙動を引き起こし、コードの可読性と保守性が低下する。

これらの理由から、C#においてstructにinterfaceを実装することは一般的に推奨されません。構造体の特性を理解し、それに応じた設計を行うことが重要です。

### 例外

- C#コンパイラーが特定のインターフェースを要求する場合でも、ボックス化のコストなしに用いることができるメソッドがあります。これらについては例外的に構造体の使用が望ましいことがあります。
